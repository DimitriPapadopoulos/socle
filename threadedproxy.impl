/*
    Socle Library Ecosystem
    Copyright (c) 2014, Ales Stibal <astib@mag0.net>, All rights reserved.

    This library  is free  software;  you can redistribute  it and/or
    modify  it  under   the  terms of the  GNU Lesser  General Public
    License  as published by  the   Free Software Foundation;  either
    version 3.0 of the License, or (at your option) any later version.
    This library is  distributed  in the hope that  it will be useful,
    but WITHOUT ANY WARRANTY;  without  even  the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    
    See the GNU Lesser General Public License for more details.
    
    You  should have received a copy of the GNU Lesser General Public
    License along with this library.
*/

#include <vector>
#include <thread>

#include <threadedproxy.hpp>
#include <logger.hpp>

template<class Com, class Worker, class SubWorker>
ThreadedAcceptor<Com,Worker,SubWorker>::ThreadedAcceptor():
threads_(NULL) {
	baseProxy<Com>::new_raw(true);
}

template<class Com, class Worker, class SubWorker>
ThreadedAcceptor<Com,Worker,SubWorker>::~ThreadedAcceptor() { 
	if(threads_)  {

		for(int i = 0; i <= nthreads; i++) {
			Worker* ptr =  workers_[i];
			ptr->dead(true);
		}
		
		for(int i = 0; i <= nthreads; i++) {
			std::thread* ptr =  threads_[i];
			ptr->join();
			delete ptr;
			threads_[i] = NULL;
		}
		delete[] threads_; 
	}
};


template<class Com, class Worker, class SubWorker>
void ThreadedAcceptor<Com,Worker,SubWorker>::on_left_new_raw(int s) {
	DIA_("ThreadedAcceptor::on_left_new: connection [%d] pushed to the queue",s);
	push(s);
}

template<class Com, class Worker, class SubWorker>
void ThreadedAcceptor<Com,Worker,SubWorker>::on_right_new_raw(int s) {
	DIA_("ThreadedAcceptor::on_right_new: connection [%d] pushed to the queue",s);
	push(s);

}


template<class Com, class Worker, class SubWorker>
int ThreadedAcceptor<Com,Worker,SubWorker>::create_workers(void) {	
	nthreads = std::thread::hardware_concurrency();
	
	INF_("Detected %d cores to use.", nthreads);
	
	threads_ = new std::thread*[nthreads];
	workers_ = new Worker*[nthreads];
	
	for( int i = 0; i < nthreads; i++) {
		Worker *w = new Worker();
		w->nonlocal(this->nonlocal());
		w->parent((baseProxy<Com>*)this);
		
		DIA_("Created ThreadedWorkerProxy %x",w);
		workers_[i] = w;
		
		// also init threads pool
		threads_[i] = NULL;
	}
	
	return nthreads;
}


template<class Com, class Worker, class SubWorker>
int ThreadedAcceptor<Com,Worker,SubWorker>::run(void) {
	
	create_workers();
	
	for( int i = 0; i < nthreads; i++) {
		auto w = workers_[i];
		std::thread* ptr = new std::thread(&Worker::run,w);
		INF_("ThreadedAcceptor::run: started new thread[%d]: ptr=%x, thread_id=%d",i,ptr,ptr->get_id())
		threads_[i] = ptr;
	}
	
	baseProxy<Com>::run();
	
	return nthreads;
}


template<class Com, class Worker, class SubWorker>
int ThreadedAcceptor<Com,Worker,SubWorker>::push(int s) { 
	std::lock_guard<std::mutex> lck(sq_lock_);
	sq_.push_front(s);
	
	return sq_.size();
};

template<class Com, class Worker, class SubWorker>
int ThreadedAcceptor<Com,Worker,SubWorker>::pop() {
	std::lock_guard<std::mutex> lck(sq_lock_);
	
	if(sq_.size() == 0) {
		return 0;
	}
	
	int s = sq_.back();
	sq_.pop_back();
	
	return s;
}



template<class Com,class SubWorker>
int ThreadedWorkerProxy<Com,SubWorker>::run_once() {
	
	ThreadedAcceptor<Com,ThreadedWorkerProxy<Com,SubWorker>,SubWorker> *p = (ThreadedAcceptor<Com,ThreadedWorkerProxy<Com,SubWorker>,SubWorker> *)MasterProxy<Com>::parent();
	if(p == NULL) {
		FATS_("PARENT is NULL");
	}
	
	if(p->dead()) {
        // set myself dead too!
        this->dead(true);
    }
	
	int s = p->pop();
	if(s > 0) {
		DIA_("ThreadedWorkerProxy::run: removed from queue: %d",s);

		auto cx = this->new_cx(s);
		if(!cx->paused()) {
            cx->accept_socket(s);
        }
		cx->nonlocal(this->nonlocal());
		cx->resolve_nonlocal_socket(s);
		this->on_left_new(cx);

	}
	
	return MasterProxy<Com>::run_once();
}
